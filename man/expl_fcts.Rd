% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/contingency-table.R
\name{expl_fcts}
\alias{expl_fcts}
\title{Explanatory Factors in Data as List of Expressions}
\usage{
expl_fcts(.data, ..., .named = FALSE, .syms = TRUE)
}
\arguments{
\item{.data}{a data frame, or a data frame extension (e.g. a \code{\link[tibble:tibble-package]{tibble}}).}

\item{...}{<\code{\link[dplyr:dplyr_tidy_select]{tidy-select}}> quoted name(s) of one or more \code{factor}s or
\verb{character vector}s in \code{.data}, to be included (or excluded) in the output.}

\item{.named}{\code{logical}, whether to name the elements of the list. If \code{TRUE}, unnamed inputs are
automatically named with \code{\link[rlang:as_label]{as_label()}}; default \code{FALSE}.}

\item{.syms}{\code{logical}. If \code{FALSE}, a \verb{character vector} is returned rather than a list of \code{symbols}; default \code{TRUE}.}
}
\value{
A \code{list} of \code{symbols} representing the names of selected explanatory \code{factors} or \verb{character vectors} in
\code{.data}; unless \code{.syms = FALSE}, in which case the selected names are returned as a \verb{character vector} instead.
}
\description{
Create a list of defused expressions representing the names of all or a selection of explanatory factors or character
vectors in a dataset.
}
\details{
By default, \code{expl_fcts()} creates a \code{\link[base:list]{list}} of \code{\link[base:name]{symbols}} i.e.,
\link[rlang:topic-defuse]{defused R expressions}, representing the names of all or a selection of explanatory factors (or
character vectors) in \code{.data}, using \code{\link[rlang:sym]{syms}} from package \pkg{\link[rlang]{rlang}}. Alternatively, if
\code{.syms = FALSE}, a \verb{character vector} of the names of the explanatory factors (or character vectors) in \code{.data} is
returned instead.

Variables in \code{.data} may be selected for inclusion or exclusion using the \code{\dots} argument and the
<\code{\link[dplyr:dplyr_tidy_select]{tidy-select}}> syntax from package \pkg{\link[dplyr]{dplyr}}, including use of
\dQuote{selection helpers}. If no \code{\dots} arguments are supplied, all categorical variables in \code{.data} will
be included in the list.

A list of \code{symbols} returned by \code{expl_fcts()} may be \dQuote{injected} into the \code{\dots} arguments of
\code{\link[=contingency_table]{contingency_table()}}, \code{\link[=xcontingency_table]{xcontingency_table()}},
\code{\link[=binom_contingency]{binom_contingency()}} and other similar functions, using the
\link[rlang:splice-operator]{splice-operator} \verb{!!!}. If \code{.syms = TRUE}, the functions \code{\link[tidyselect:all_of]{all_of}} or
\code{\link[tidyselect:all_of]{any_of}} should be used to wrap the resulting \verb{character vector} of names instead of using
\verb{!!!}. A list of \code{symbols} returned by \code{expl_fcts()} may also be used to provide a list argument with injection
support to \pkg{\link[purrr]{purrr}} package \link[purrr:map]{map} functions, using the
\link[rlang:injection-operator]{injection-operator} \verb{!!} (see examples).
}
\examples{
(d <- list(
    iv2 = list(g = c("a", "c", "e"), h = c("b", "d", "f")),
    iv3 = list(i = c("a", "b", "c"), j = c("d", "e", "f")),
    iv4 = list(k = c("a", "b"), l = c("c", "d"), m = c("e", "f"))
) |> add_grps(bernoulli_data(levels = 6), iv, .key = _))

d |> expl_fcts()
d |> expl_fcts(.named = TRUE)
d |> expl_fcts(.syms = FALSE)
d |> expl_fcts(.named = TRUE, .syms = FALSE)

## Select or exclude factors
d |> expl_fcts(iv, iv3)
d |> expl_fcts(!c(iv, iv3))

## Use {dplyr} selection helpers e.g., last_col(), num_range() and starts_with()
d |> expl_fcts(last_col(1L))  ## Offset of 1L used, since last column of d is dv
d |> expl_fcts(!last_col())
d |> expl_fcts(num_range("iv", 2:3))
d |> expl_fcts(!num_range("iv", 2:3))
d |> expl_fcts(starts_with("iv"))
## Negation of selection helper excludes all explanatory factors
d |> expl_fcts(!starts_with("iv"))

## In following three examples, each triplet should give identical results
## Include all explanatory factors
d |> binom_contingency(dv)
d |> binom_contingency(dv, !!!expl_fcts(d))
d |> binom_contingency(dv, all_of(expl_fcts(d, .syms = FALSE)))

## Include only iv and iv3
d |> binom_contingency(dv, iv, iv3)
d |> binom_contingency(dv, !!!expl_fcts(d, iv, iv3))
d |> binom_contingency(dv, all_of(expl_fcts(d, iv, iv3, .syms = FALSE)))

## Exclude iv and iv3
d |> binom_contingency(dv, !c(iv, iv3))
d |> binom_contingency(dv, !!!expl_fcts(d, !c(iv, iv3)))
d |> binom_contingency(dv, all_of(expl_fcts(d, !c(iv, iv3), .syms = FALSE)))

## Use with purr::map(), binom_contingency(), glm() and odds_ratio()
expl_fcts(d, .named = TRUE) |>
    map(\(x) binom_contingency(d, dv, !!x))
expl_fcts(d, .named = TRUE) |>
    map(\(x) binom_contingency(d, dv, !!x) |> glm(cbind(pn, qn) ~ ., binomial, data = _))
expl_fcts(d, .named = TRUE) |>
    map(\(x) binom_contingency(d, dv, !!x, .drop_zero = T) |> odds_ratio(.ind_var = !!x))

rm(d)
}
\seealso{
\code{\link[rlang:injection-operator]{!!}}, \code{\link[rlang:splice-operator]{!!!}}, \code{\link[tidyselect:all_of]{all_of}},
\code{\link[tidyselect:all_of]{any_of}}, \code{\link[rlang:as_label]{as_label()}}, \code{\link[rlang:topic-defuse]{defused R expressions}},
\code{\link[purrr:map]{map()}} and \code{\link[base:name]{symbol}}.

Other contingency_table: 
\code{\link{binom_contingency}()},
\code{\link{contingency_table}()}
}
\concept{contingency_table}
\keyword{manip}
\keyword{models}
